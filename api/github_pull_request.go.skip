package api

import (
	"context"
	"log"

	"github.com/google/go-github/v53/github"
	"github.com/jericop/pr-compliance-app/storage/postgres"
)

// Handles a PullRequestEvent
func (server *Server) processPullRequestEvent(ctx context.Context, client *github.Client, event *github.PullRequestEvent) {
	prNum := event.PullRequest.GetNumber()
	owner := event.Repo.GetOwner().GetLogin()
	repoName := event.Repo.GetName()
	sha := *event.GetPullRequest().GetHead().SHA

	switch event.GetAction() {
	case "opened", "synchronize", "reopened":
		repo, err := server.querier.GetRepo(ctx, int32(event.Repo.GetID()))
		if err != nil {
			log.Printf("Error getting repo %s with id %d\n", repoName, event.Repo.GetID())
		}

		log.Printf("repo (%T) %v\n", repo, repo)

		repo2, err := server.querier.GetRepo(ctx, 1234567890)
		log.Printf("repo2 (%T) %v\n", repo2, repo2)

		// if repo is nil (or repo.ID is nil) then create one

		prQueryParams := postgres.GetPullRequestByRepoIdPrIdParams{
			RepoID: repo.ID,
			PrID:   int32(event.PullRequest.GetID()),
		}

		pr, err := server.querier.GetPullRequestByRepoIdPrId(ctx, prQueryParams)
		if err != nil {
			log.Printf("Error getting pr %s/%d with id %d\n", repoName, prNum, prQueryParams.PrID)
		}

		log.Printf("pr (%T) %v\n", pr, pr)

		// if pr is nil (or pr.PrID is nil) then create one

		prEventParams := postgres.CreatePullRequestEventParams{
			PrID:     int32(event.Repo.GetID()),
			Action:   event.GetAction(),
			Sha:      sha,
			IsMerged: event.PullRequest.GetMerged(),
		}
		log.Printf("prEventParams (%T) %v\n", prEventParams, prEventParams)

		prEvent, err := server.querier.CreatePullRequestEvent(ctx, prEventParams)
		if err != nil {
			log.Printf("Error creating pull request event pr %#v\n", prEventParams)
		}

		log.Printf("prEvent (%T) %v\n", prEvent, prEvent)

		// get repo_id
		// Query db for repo
		// Add it if missing

		// get pr_id
		// Query db for pr for "synchronize" and "reopened" and events
		// if "opened" event we need to create a new entry

		// Add event to pull_request_event table

		// Query approval
		// Create an approval if missing

		log.Printf("Creating a commit status for pull request %s/%d created by %s\n", repoName, prNum, owner)

		failedStatus := &github.RepoStatus{
			// TODO: Get these fields from the database at startup and then use them for all requests
			Context:     github.String(statusContext),
			Description: github.String(statusTitle),
			// TargetURL: github.String("https://github.com"),
			State: github.String("error"), // "error" or "failure" show up as a red X
		}

		status, response, err := client.Repositories.CreateStatus(ctx, owner, repo.Name, sha, failedStatus)

		if err == nil {
			log.Printf("Successfully created commit status for pull request %s/%d\n", repoName, prNum)
		} else {
			log.Printf("Failed to create commit status for pull request %s/%d\n", repoName, prNum)
			log.Printf("status: %v\n", status)
			log.Printf("response: %v\n", response) // You can keep track of rate limit usage from this
			log.Printf("err: %v\n", err)
			return
		}

	case "closed":
		log.Printf("Pull request %s/%d created by %s has been closed.\n", repoName, prNum, owner)
		// TODO: Add the event to an activity table with the status of whether it was merged or not. This allows for multiple closed/reopened events.
		// See: https://docs.github.com/en/rest/pulls/pulls?apiVersion=2022-11-28#check-if-a-pull-request-has-been-merged
	}
}
