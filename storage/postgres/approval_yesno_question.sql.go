// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: approval_yesno_question.sql

package postgres

import (
	"context"
)

const getSortedApprovalYesNoQuestionAnswersByUuid = `-- name: GetSortedApprovalYesNoQuestionAnswersByUuid :many
WITH false_answers AS (
  SELECT q.id, q.question_text
  FROM approval_yesno_question q, approval a
  WHERE 
    a.uuid = $1 AND
    q.schema_id = a.schema_id
), true_answers AS (
  SELECT ya.question_id
  FROM approval a, approval_yes_answer ya
  WHERE 
    a.uuid = $1 AND 
    ya.approval_id = a.id
)
SELECT 
  f.id, 
  f.question_text, 
  CASE WHEN EXISTS (SELECT 1 FROM true_answers WHERE question_id=f.id) THEN true ELSE false END as answered_yes
FROM false_answers f
ORDER BY f.id
`

type GetSortedApprovalYesNoQuestionAnswersByUuidRow struct {
	ID           int32  `json:"id"`
	QuestionText string `json:"question_text"`
	AnsweredYes  bool   `json:"answered_yes"`
}

func (q *Queries) GetSortedApprovalYesNoQuestionAnswersByUuid(ctx context.Context, uuid string) ([]GetSortedApprovalYesNoQuestionAnswersByUuidRow, error) {
	rows, err := q.db.Query(ctx, getSortedApprovalYesNoQuestionAnswersByUuid, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSortedApprovalYesNoQuestionAnswersByUuidRow{}
	for rows.Next() {
		var i GetSortedApprovalYesNoQuestionAnswersByUuidRow
		if err := rows.Scan(&i.ID, &i.QuestionText, &i.AnsweredYes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSortedApprovalYesNoQuestionsBySchemaId = `-- name: GetSortedApprovalYesNoQuestionsBySchemaId :many
SELECT id, question_text FROM approval_yesno_question
WHERE schema_id = (SELECT id FROM approval_schema WHERE name = $1) 
GROUP BY id, question_text
`

type GetSortedApprovalYesNoQuestionsBySchemaIdRow struct {
	ID           int32  `json:"id"`
	QuestionText string `json:"question_text"`
}

func (q *Queries) GetSortedApprovalYesNoQuestionsBySchemaId(ctx context.Context, name string) ([]GetSortedApprovalYesNoQuestionsBySchemaIdRow, error) {
	rows, err := q.db.Query(ctx, getSortedApprovalYesNoQuestionsBySchemaId, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSortedApprovalYesNoQuestionsBySchemaIdRow{}
	for rows.Next() {
		var i GetSortedApprovalYesNoQuestionsBySchemaIdRow
		if err := rows.Scan(&i.ID, &i.QuestionText); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
